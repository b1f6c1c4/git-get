#!/bin/bash

set -euo pipefail

usage()
{
    cat - <<EOF
git-get
    [-v|--verbose|-q|--quiet]
    <url> | <user>/<repo>
    [<branch>|<sha1>]
    [-o <target>] [-f|--force] [-F|--rm-rf]
    [-t [--tag-file=VERSION]]
    [--token <token> | --token-file <file>]
    [-r|--recursive] [-j<N>] [-- <path>]
EOF
}

git_new() {
    V="$(git version)"
    [[ "$V" =~ ^git[[:space:]]version[[:space:]]2\..\. ]] && return 1
    [[ "$V" =~ ^git[[:space:]]version[[:space:]]2\.1.\. ]] && return 1
    return 0
}

fakerealpath() {
    if [[ "$1" =~ ^/ ]]; then
        printf '%s' "$1"
    else
        printf '%s/%s' "$PWD" "$1"
    fi
}

TOKEN=
TOKEN_FILE="$HOME/.github-token"
QUIET=
VERBOSE=
RECURSIVE=
FORCE=
FORCE_DIR=
OUTPUT=
TAG=
TAG_FILE=
JOBS=1
DIR=
POSITIONAL=()
while [ $# -gt 0 ]; do
    key="$1"
    case "$key" in
        -h|--help)
            usage
            exit
            ;;
        -q|--quiet)
            QUIET=--quiet
            shift
            ;;
        -v|--verbose)
            VERBOSE=YES
            shift
            ;;
        -r|--recursive)
            RECURSIVE=YES
            shift
            ;;
        -f|--force)
            FORCE=YES
            shift
            ;;
        -F|--rm-rf)
            FORCE_DIR=YES
            shift
            ;;
        -o|--output)
            OUTPUT="$2"
            shift
            shift
            ;;
        -o-)
            OUTPUT="-"
            shift
            ;;
        -t|--tag)
            TAG=YES
            shift
            ;;
        --tag-file)
            TAG=YES
            TAG_FILE="$2"
            shift
            shift
            ;;
        -j|--jobs)
            JOBS="$2"
            shift
            shift
            ;;
        --token)
            TOKEN="$2"
            TOKEN_FILE=""
            shift
            shift
            ;;
        --token-file)
            TOKEN=""
            TOKEN_FILE="$2"
            shift
            shift
            ;;
        --)
            DIR="$2"
            shift
            shift
            break
            ;;
        *)
            if [[ "$1" =~ ^-j ]]; then
                JOBS="${1#-j}"
                shift
            else
                POSITIONAL+=("$1")
                shift
            fi
            ;;
    esac
done

if [ "$#" -gt 0 ]; then
    echo "Error: Only one path allowed!" >&2
    exit 1
fi

if [ "${#POSITIONAL[@]}" -eq 0 ]; then
    echo "Error: Must specify <repo-url> (any git remote) or <user>/<repo> (GitHub)"
    exit 1
elif [ "${#POSITIONAL[@]}" -eq 1 ]; then
    BRANCH="HEAD"
elif [ "${#POSITIONAL[@]}" -eq 2 ]; then
    BRANCH="${POSITIONAL[1]}"
else
    echo "Error: Too many positional arguments, maybe you forgot -- before <path>?" >&2
    exit 1
fi

if [[ "${POSITIONAL[0]}" =~ ^https://github.com/ ]]; then
    GITHUB=YES
    GH_REPO="${POSITIONAL[0]#https://github.com/}"
    GH_REPO="${GH_REPO%.git}"
    REPO="${POSITIONAL[0]}"
elif [[ "${POSITIONAL[0]}" =~ ^git@github.com: ]]; then
    GITHUB=YES
    GH_REPO="${POSITIONAL[0]#git@github.com:}"
    GH_REPO="${GH_REPO%.git}"
    REPO="${POSITIONAL[0]}"
elif [[ "${POSITIONAL[0]}" =~ ^.*/.*/.*$ ]]; then
    REPO="${POSITIONAL[0]}"
else
    GITHUB=YES
    GH_REPO="${POSITIONAL[0]}"
    REPO="git@github.com:${POSITIONAL[0]}.git"
fi

if [ ! -z "$DIR" ]; then
    BASENAME="$(basename "$DIR")"
else
    BASENAME="$(basename "$REPO")"
    BASENAME="${BASENAME%.git}"
fi
if [ -z "$OUTPUT" ]; then
    OUTPUT="$BASENAME"
fi

if [ ! -z "$TAG" ]; then
    if [ -z "$TAG_FILE" ]; then
        TAG_FILE="VERSION"
    fi
else
    TAG_FILE=
fi

if [ -z "$TOKEN" ] && [ -f "$TOKEN_FILE" ]; then
    TOKEN="$(cat "$TOKEN_FILE")"
fi

which git >/dev/null
if [ $? -ne 0 ]; then
    echo "Error: git(1) not found"
    exit 66
fi

git_new || ([ ! -z "$QUIET" ] && printf 'Warning: You should upgrade your git (currently %s)\n' "$(git version)" >&2)

if [ ! -z "$FORCE_DIR" ]; then
    FORCE=YES
fi
if [ ! "$OUTPUT" = '-' ]; then
    OUTPUT="$(fakerealpath "$OUTPUT")"
fi
OCWD="$PWD"
if [ ! -z "$VERBOSE" ]; then
    if [ ! -z "$TOKEN" ]; then
        printf 'TOKEN=%s\n' "********" >&2
    else
        printf 'TOKEN=%s\n' "" >&2
    fi
    printf 'OCWD=%q\n' "$OCWD" >&2
    printf 'FORCE=%q\n' "$FORCE" >&2
    printf 'FORCE_DIR=%q\n' "$FORCE_DIR" >&2
    printf 'OUTPUT=%q\n' "$OUTPUT" >&2
    printf 'TAG_FILE=%q\n' "$TAG_FILE" >&2
    printf 'GITHUB=%q\n' "$GITHUB" >&2
    printf 'GH_REPO=%q\n' "$GH_REPO" >&2
    printf 'REPO=%q\n' "$REPO" >&2
    printf 'RECURSIVE=%q\n' "$RECURSIVE" >&2
    printf 'JOBS=%q\n' "$JOBS" >&2
    printf 'BRANCH=%q\n' "$BRANCH" >&2
    printf 'DIR=%q\n' "$DIR" >&2
    printf 'BASENAME=%q\n' "$BASENAME" >&2
fi

[ ! -z "$RECURSIVE" ] && echo 'Error: Not yet supported.' >&2 && exit 114

WORK_DIR="$(mktemp -d)"
finish() {
    cd /
    rm -rf "$WORK_DIR"
}
trap finish EXIT
cd "$WORK_DIR"

[ ! -z "$VERBOSE" ] && printf 'WORK_DIR=%q\n' "$WORK_DIR" >&2

got_file() {
    set -e
    if [ "$OUTPUT" = "-" ]; then
        cat "$1"
    elif [ -f "$OUTPUT" ]; then
        if [ ! -z "$FORCE" ]; then
            [ -z "$QUIET" ] && printf 'Warning: Overriding file %q\n' "$OUTPUT" >&2
            mv -f "$1" "$OUTPUT"
        else
            printf 'Error: File %q exists\n' "$OUTPUT" >&2
            exit 1
        fi
    else
        mv "$1" "$OUTPUT"
    fi
    [ ! -z "$VERBOSE" ] && printf 'size used in /tmp = %s\n' "$(du -sh "$WORK_DIR")" >&2
    [ -z "$QUIET" ] && printf 'tag = %s\n' "$2" >&2
    if [ ! -z "$TAG" ]; then
        if [[ "$TAG_FILE" =~ ^/ ]]; then
            printf '%s\n' "$2" >"$TAG_FILE"
        else
            printf '%s\n' "$2" >"$OCWD/$TAG_FILE"
        fi
    fi
    exit 0
}

got_dir() {
    set -e
    if [ "$OUTPUT" = "-" ]; then
        [ ! -z "$VERBOSE" ] && (cd "$(dirname "$1")" && ls -lhAR "$(basename "$1")" >&2)
        (cd "$(dirname "$1")" && tar c "$(basename "$1")")
    elif [ -d "$OUTPUT" ]; then
        if [ ! -z "$FORCE_DIR" ]; then
            [ -z "$QUIET" ] && printf 'Warning: Overriding directory %q\n' "$OUTPUT" >&2
            rm -rf "$OUTPUT" && mv "$1" "$OUTPUT"
        else
            mv "$1" "$OUTPUT"
        fi
    elif [ -f "$OUTPUT" ]; then
        if [ ! -z "$FORCE" ]; then
            [ -z "$QUIET" ] && printf 'Warning: Overriding file %q\n' "$OUTPUT" >&2
            rm -f "$OUTPUT" && mv "$1" "$OUTPUT"
        else
            printf 'Error: File %q exists\n' "$OUTPUT" >&2
            exit 1
        fi
    else
        mv "$1" "$OUTPUT"
    fi
    [ ! -z "$VERBOSE" ] && printf 'size used in /tmp = %s\n' "$(du -sh "$WORK_DIR")" >&2
    [ -z "$QUIET" ] && printf 'tag = %s\n' "$2" >&2
    if [ ! -z "$TAG" ]; then
        if [[ "$TAG_FILE" =~ ^/ ]]; then
            printf '%s\n' "$2" >"$TAG_FILE"
        elif [ "$OUTPUT" = "-" ]; then
            printf '%s\n' "$2" >"$OCWD/$TAG_FILE"
        else
            printf '%s\n' "$2" >"$OUTPUT/$TAG_FILE"
        fi
    fi
    exit 0
}

got_repo() {
    set -e
    git --git-dir="$1/.git" config --bool core.bare false
    if [ -z "$DIR" ]; then
        ARGS=(git reset --hard)
        [ ! -z "$QUIET" ] && ARGS+=(-q)
        [   -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" >&2)
        [ ! -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" 2>/dev/null >&2)
        mv "$1/.git" ".git"
        got_dir "$1" "$2" && exit 0
    else
        # git restore --worktree issue fetch-pack one-by-another
        # which is super slow
        ARGS=(git reset HEAD)
        [ ! -z "$QUIET" ] && ARGS+=(-q)
        ARGS+=(-- "$DIR")
        [   -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" >&2)
        [ ! -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" 2>/dev/null >&2)

        ARGS=(git restore --worktree)
        [ ! -z "$QUIET" ] && ARGS+=(-q)
        ARGS+=(-- "$DIR")
        [   -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" >&2)
        [ ! -z "$QUIET" ] && (cd "$1" && "${ARGS[@]}" 2>/dev/null >&2)
        [ -f "$1/$DIR" ] && got_file "$1/$DIR" "$2"
        [ -d "$1/$DIR" ] && got_dir "$1/$DIR" "$2"
        echo 'Error: File type not supported.' >&2
        exit 2
    fi
}

# TODO: recursive into submodules?
# 0. git 2.20+ -> shallow + [filter] -> filter
if git_new; then
    mkdir -p "$BASENAME"
    ARGS=(git clone --bare)
    [ ! -z "$QUIET" ] && ARGS+=(-q)
    [ ! "$BRANCH" = "HEAD" ] && ARGS+=(--branch "$BRANCH")
    ARGS+=(--depth 1 --no-tags)
    [ ! -z "$DIR" ] && ARGS+=(--filter blob:none)
    ARGS+=("$REPO" "$BASENAME/.git")
    [ ! -z "$VERBOSE" ] && (printf '%q ' "${ARGS[@]}" >&2; printf '\n'>&2)
    set +e
    "${ARGS[@]}" 2>&1 | tee clone.log >&2
    if [ "$?" -eq 0 ]; then
        set -e
        got_repo "$BASENAME" "$(git --git-dir="$BASENAME/.git" rev-parse HEAD)"
    fi
    set -e
    if [ ! -z "$(grep 'warning: Could not find remote branch' clone.log)" ]; then
        ARGS=(git clone --mirror --filter tree:0)
        [ ! -z "$QUIET" ] && ARGS+=(-q)
        ARGS+=("$REPO" "$BASENAME/.git")
        [ ! -z "$VERBOSE" ] && (printf '%q ' "${ARGS[@]}" >&2; printf '\n'>&2)
        set +e
        "${ARGS[@]}"
        if [ "$?" -eq 0 ]; then
            SHA1="$(git --git-dir="$BASENAME/.git" rev-parse "$BRANCH")"
            if [ ! -z "$SHA1" ]; then
                [ -z "$QUIET" ] && printf 'Got SHA1: %q\n' "$SHA1" >&2
                set -e
                git --git-dir="$BASENAME/.git" update-ref --no-deref HEAD "$SHA1"
                got_repo "$BASENAME" "$SHA1"
            fi
        fi
        set -e
    fi
    rm -rf "$BASENAME"
fi

# TODO: recursive into submodules?
# 1. GitHub / Path -> api.github.com/.../contents
if [ ! -z "$GITHUB" ] && [ ! -z "$DIR" ]; then
    ARGS=(curl -f -o file)
    ARGS+=(-w '%{content_type}')
    ARGS+=(-H 'Accept: application/vnd.github.v3.raw')
    [ ! -z "$TOKEN" ] && ARGS+=(-H "Authorization: token $TOKEN")
    [ ! -z "$QUIET" ] && ARGS+=(-s)
    [ ! -z "$VERBOSE" ] && ARGS+=(-S)
    ARGS+=("https://api.github.com/repos/$GH_REPO/contents/$DIR?ref=$BRANCH")
    [ ! -z "$VERBOSE" ] && (printf '%q ' "${ARGS[@]}" >&2; printf '\n'>&2)
    set +e
    RES="$("${ARGS[@]}")"
    if [ "$?" -eq 0 ]; then
        set -e
        [[ "$RES" =~ ^application/vnd.github.v3.raw ]] && got_file file "$BRANCH"
        # [[ "$RES" =~ ^application/json ]] && IS_DIR=YES
    fi
    set -e
fi

printf 'Error: No viable method.\n' >&2
exit 0

REPO_DIR="$WORK_DIR/.git"

git init $QUIET "$WORK_DIR"
git --git-dir="$REPO_DIR" remote add origin "$REPO"
if [ ! -z "$VERBOSE" ]; then
    echo "Remote:" "$REPO"
fi

set -- $SHA1
SHA1=$1

if [ ! -z "$VERBOSE" ]; then
    echo "Retrived SHA1:" $SHA1
fi

if [ -z "$OUTPUT" ]; then
    OUTPUT="./"
fi
IS_FINAL=$(echo "$OUTPUT" | grep '/$')
if [ ! -z "$IS_FINAL" ]; then
    if [ -z "$DIR" ]; then
        OUTPUT="$OUTPUT$(basename "$REPO")"
    else
        OUTPUT="$OUTPUT$(basename "$DIR")"
    fi
fi

if [ ! -z "$VERBOSE" ]; then
    echo "Output directory:" "$OUTPUT"
fi

GIT_VERSION=$(git --version | grep -P '^git version (2\.1[8-9]|2\.[2-9][0-9]|2\.[0-9][0-9][0-9]+|[3-9]\.[0-9]+|[1-9][0-9]+\.[0-9]+)(\.[0-9]+)?$')
if [ -z "$GIT_VERSION" ]; then
    echo "[31m$(git --version) is too old, please use 2.18+[0m"
    if [ "$LEGACY" = "NO" ]; then
        exit 18
    fi
    echo "fallback to legacy mode"
    LEGACY=YES
fi
if [ "$LEGACY" = "NO" ]; then
    echo "Unfortunately, this feature has not been implemented."
    exit 233 # TODO
    LEGACY=
fi

LEGACY=YES # TODO

git-download-fetcher()
{
    # $1 = verbose
    # $2 = legacy
    # $3 = quiet
    # $4 = worktree
    # $5 = remote repo
    # $6 = sha1

    VREBOSE="$1"
    shift
    if [ ! -z "$VERBOSE" ]; then
        echo "Fetcher:" "$@"
    fi
    LEGACY="$1"
    shift
    QUIET="$1"
    shift
    F_REPO="$1/.git"
    F_WORK="$1"
    shift
    F_REMO="$1"
    shift
    F_SHA1="$1"
    shift

    REMO_GIT=$(echo "$F_REMO" | sed -E 's_^https://([^/]+)/_git@\1:_')
    if [ ! -z "$VERBOSE" ]; then
        echo "Modified remote:" "$REMO_GIT"
    fi

    if [ ! -z "$LEGACY" ]; then
        if [ ! -d "$F_REPO" ]; then
            mkdir -p "$F_WORK"
            git init $QUIET "$F_WORK"
        fi
        if [ -z "$QUIET" ]; then
            git --git-dir="$F_REPO" fetch-pack --depth=1 "$REMO_GIT" "$F_SHA1"
        else
            git --git-dir="$F_REPO" fetch-pack --quiet --no-progress --depth=1 "$REMO_GIT" "$F_SHA1" > /dev/null
        fi
        if [ $? -ne 0 ]; then
            exit 2
        fi
    else
        echo "Unfortunately, this feature has not been implemented."
        exit 233 # TODO
    fi
}
export -f git-download-fetcher

WALKER_REPO=
WALKER_WORK=
WALKER_RESULT=
WALKER_TYPE=
WALKER_MODE=
WALKER_BSHA=
WALKER_PATH=
walker()
{
    # $1 = worktree
    # $2 = base sha1
    # $3 = path
    # $4 = sha1
    # $5 = target path

    if [ ! -z "$VERBOSE" ]; then
        echo "Walker:" "$@"
    fi
    W_REPO="$1/.git"
    W_WORK="$1"
    shift
    W_BSHA="$1"
    shift
    W_PATH="$1"
    shift
    W_SHA1="$1"
    shift
    W_TARG="$1"
    shift
    FIRST=$(echo "$W_TARG" | sed -E 's_^([^/]*)(/.*)?$_\1_') # TODO: bad regex
    REST=$(echo "$W_TARG" | sed -E 's_^[^/]*(/(.*))?$_\2_') # TODO: bad regex
    if [ -z "$W_PATH" ]; then
        WN_PATH="$FIRST"
    else
        WN_PATH="$W_PATH/$FIRST"
    fi
    if [ -z "$W_TARG" ]; then
        LSTREE="040000 tree $W_SHA1 "
    else
        LSTREE="$(git --git-dir="$W_REPO" ls-tree "$W_SHA1" -- "$FIRST")"
    fi
    if [ $? -ne 0 ]; then
        exit 4
    fi
    set -- $LSTREE
    TYPE=$2
    WN_SHA1=$3
    if [ "$TYPE" = "commit" ]; then
        WN_WORK="$W_WORK/$WN_PATH"
        git --git-dir="$W_REPO" cat-file blob "$W_BSHA:.gitmodules" > "$W_WORK/.gitmodules"
        git config --file="$W_WORK/.gitmodules" --get-regexp 'submodule\..*\.path' > "$W_WORK/walker_temp"
        if [ $? -ne 0 ]; then
            echo "Can't clone submodule: .gitmodules not found"
            exit 190
        fi
        NM=$(grep -F ".path $WN_PATH" "$W_WORK/walker_temp")
        if [ -z "$NM" ]; then
            echo "Can't clone submodule: submodules not found"
            exit 191
        fi
        NMX=$(echo "$NM" | cut -f2 -d.)
        URL=$(git config --file="$W_WORK/.gitmodules" --get "submodule.$NMX.url")
        if [ ! -z "$VERBOSE" ]; then
            echo "Submodule found:" "$NMX" "$URL"
        fi
        git-download-fetcher "$VERBOSE" "$LEGACY" "$QUIET" "$WN_WORK" "$URL" "$WN_SHA1"
        WN_SHA1=$(git --git-dir="$WN_WORK/.git" rev-parse "$WN_SHA1^{tree}")
        if [ $? -ne 0 ]; then
            echo "Can't find tree from commit"
            exit 192
        fi
        if [ -z "$REST" ]; then
            WALKER_WORK="$WN_WORK"
            WALKER_RESULT="$WN_SHA1"
            WALKER_TYPE="tree"
            WALKER_MODE=
            WALKER_BSHA="$WN_SHA1"
            WALKER_PATH="$WN_PATH"
            if [ ! -z "$VERBOSE" ]; then
                echo "Walker suceed:" "$WALKER_WORK" "$WALKER_RESULT" "$WALKER_TYPE" "$WALKER_MODE"
            fi
        else
            walker "$WN_WORK" "$WN_SHA1" "." "$WN_SHA1" "$REST"
        fi
    elif [ "$TYPE" = "tree" ]; then
        if [ -z "$REST" ]; then
            WALKER_WORK="$W_WORK"
            WALKER_RESULT="$WN_SHA1"
            WALKER_TYPE="tree"
            WALKER_MODE=
            WALKER_BSHA="$W_BSHA"
            WALKER_PATH="$W_PATH"
            if [ ! -z "$VERBOSE" ]; then
                echo "Walker suceed:" "$WALKER_WORK" "$WALKER_RESULT" "$WALKER_TYPE" "$WALKER_MODE"
            fi
        else
            walker "$W_WORK" "$W_BSHA" "$WN_PATH" "$WN_SHA1" "$REST"
        fi
    elif [ "$TYPE" = "blob" ]; then
        if [ -z "$REST" ]; then
            WALKER_WORK="$W_WORK"
            WALKER_RESULT="$WN_SHA1"
            WALKER_TYPE="blob"
            WALKER_MODE="$1"
            WALKER_BSHA="$W_BSHA"
            WALKER_PATH="$W_PATH"
            if [ ! -z "$VERBOSE" ]; then
                echo "Walker suceed:" "$WALKER_WORK" "$WALKER_RESULT" "$WALKER_TYPE" "$WALKER_MODE"
            fi
        else
            echo "$W_SHA1/$FIRST is a file, you can't walk into it"
            exit 17
        fi
    else
        echo "Type $TYPE not supported"
        exit 20
    fi
    WALKER_REPO="$WALKER_WORK/.git"
}

git-download-recurse()
{
    # $1: verbose
    # $2: legacy
    # $3: quiet
    # $4: work
    # $5: base sha1
    # $6: path
    # $7: target
    # $8: mode
    # $9: type
    # $a: sha1
    # $b...: path

    VERBOSE="$1"
    shift
    if [ ! -z "$VERBOSE" ]; then
        echo "Recurse:" "$@"
    fi
    LEGACY="$1"
    shift
    QUIET="$1"
    shift
    R_REPO="$1/.git"
    R_WORK="$1"
    shift
    R_BSHA="$1"
    shift
    R_PATH="$1"
    shift
    R_TARGET="$1"
    shift

    if [ -z "$*" ]; then
        return
    fi

    set -- $*
    R_MODE="$1"
    shift
    R_TYPE="$1"
    shift
    R_SHA1="$1"
    shift
    R_NEXT="$*"
    if [ -z "$R_PATH" ]; then
        RN_PATH="$R_NEXT"
    else
        RN_PATH="$R_PATH/$R_NEXT"
    fi
    if [ "$R_TYPE" = "tree" ]; then
        git --git-dir="$R_REPO" ls-tree "$R_SHA1" | grep -v '^100... blob ' | xargs -l bash -c 'git-download-recurse "$@"' "$@" "$VERBOSE" "$LEGACY" "$QUIET" "$R_WORK" "$R_BSHA" "$R_PATH" "$R_TARGET/$R_NEXT"
    elif [ "$R_TYPE" = "commit" ]; then
        RN_WORK="$R_WORK/$R_NEXT"
        RN_TARGET="$R_TARGET/$R_NEXT"
        git --git-dir="$R_REPO" cat-file blob "$R_BSHA:.gitmodules" > "$R_WORK/.gitmodules"
        git config --file="$R_WORK/.gitmodules" --get-regexp 'submodule\..*\.path' > "$R_WORK/walker_temp"
        if [ $? -ne 0 ]; then
            echo "Can't clone submodule: .gitmodules not found"
            exit 290
        fi
        NM=$(grep -F ".path $RN_PATH" "$R_WORK/walker_temp")
        if [ -z "$NM" ]; then
            echo "Can't clone submodule: submodules not found"
            exit 291
        fi
        NMX=$(echo "$NM" | cut -f2 -d.)
        URL=$(git config --file="$R_WORK/.gitmodules" --get "submodule.$NMX.url")
        if [ ! -z "$VERBOSE" ]; then
            echo "Submodule found:" "$NMX" "$URL"
        fi
        git-download-fetcher "$VERBOSE" "$LEGACY" "$QUIET" "$RN_WORK" "$URL" "$R_SHA1"
        RN_SHA1=$(git --git-dir="$RN_WORK/.git" rev-parse "$R_SHA1^{tree}")
        if [ $? -ne 0 ]; then
            echo "Can't find tree from commit"
            exit 292
        fi
        rm -fd "$RN_TARGET"
        if [ $? -ne 0 ]; then
            echo "Can't remove the empty folder"
            exit 293
        fi
        git-download-exporter "$VERBOSE" "$LEGACY" "$QUIET" "YES" "$RN_WORK" "$RN_SHA1" "" "$RN_SHA1" "$RN_TARGET"
    else
        echo "Warning: type $R_TYPE not supported"
    fi
}
export -f git-download-recurse

git-download-exporter()
{
    # $1: verbose
    # $2: legacy
    # $3: quiet
    # $4: recursive
    # $5: work
    # $6: base sha1
    # $7: path
    # $8: sha1
    # $9: target

    VREBOSE="$1"
    shift
    if [ ! -z "$VERBOSE" ]; then
        echo "Exporter:" "$@"
    fi
    LEGACY="$1"
    shift
    QUIET="$1"
    shift
    RECURSIVE="$1"
    shift
    E_WORK="$1"
    E_REPO="$1/.git"
    shift
    E_BSHA="$1"
    shift
    E_PATH="$1"
    shift
    E_RESULT="$1"
    shift
    E_OUTPUT="$1"
    shift

    git --git-dir="$E_REPO" --work-tree="$E_WORK" read-tree "$E_RESULT"
    if [ -d "$OUTPUT" ]; then
        if [ ! -z "$FORCE_DIR" ]; then
            rm -rf "$E_OUTPUT"
        else
            echo "Output path is a folder and you try to replace it with a folder; use --rm-rf if that's what you want."
            exit 23
        fi
    elif [ -f "$OUTPUT" ]; then
        if [ ! -z "$FORCE" ]; then
            rm -f "$E_OUTPUT"
        else
            echo "Output path is a file and you try to replace it with a folder; use --force if that's what you want."
            exit 23
        fi
    fi
    git --git-dir="$E_REPO" --work-tree="$E_WORK" checkout-index -f --prefix="result/" -a
    if [ $? -ne 0 ]; then
        exit 24
    fi
    mv "$E_WORK/result" "$E_OUTPUT"
    if [ $? -ne 0 ]; then
        exit 26
    fi
    if [ ! -z "$RECURSIVE" ]; then
        git --git-dir="$E_REPO" ls-tree "$E_RESULT" | grep -v '^100... blob ' | xargs -l bash -c 'git-download-recurse "$@"' "$0" "$VERBOSE" "$LEGACY" "$QUIET" "$E_WORK" "$E_BSHA" "$E_PATH" "$E_OUTPUT"
    fi
}
export -f git-download-exporter

if [ ! -z "$LEGACY" ]; then
    git-download-fetcher "$VERBOSE" "$LEGACY" "$QUIET" "$WORK_DIR" "$REPO" "$SHA1"
    walker "$WORK_DIR" "$SHA1" "" "$SHA1" "$DIR"

    if [ ! -z "$VERBOSE" ]; then
        echo "Type:" "$WALKER_TYPE"
    fi

    if [ "$WALKER_TYPE" = "tree" ]; then
        git-download-exporter "$VERBOSE" "$LEGACY" "$QUIET" "$RECURSIVE" "$WALKER_WORK" "$WALKER_BSHA" "$WALKER_PATH" "$WALKER_RESULT" "$OUTPUT"
    elif [ "$WALKER_TYPE" = "blob" ]; then
        if [ -d "$OUTPUT" ]; then
            if [ ! -z "$FORCE_DIR" ]; then
                rm -rf "$OUTPUT"
            else
                echo "Output path is a folder and you try to replace it with a file; use --rm-rf if that's what you want."
                exit 23
            fi
        elif [ -f "$OUTPUT" ]; then
            if [ ! -z "$FORCE" ]; then
                rm -f "$OUTPUT"
            else
                echo "Output path is a file and you try to replace it with a file; use --force if that's what you want."
                exit 23
            fi
        fi
        git --git-dir="$WALKER_REPO" cat-file blob "$WALKER_RESULT" > "$WALKER_WORK/result"
        if [ $? -ne 0 ]; then
            exit 24
        fi
        if [ "$WALKER_MODE" = "100644" ]; then
            chmod 644 "$WALKER_WORK/result"
        elif [ "$WALKER_MODE" = "100755" ]; then
            chmod 755 "$WALKER_WORK/result"
        else
            echo "Warning: mode not supported: $WALKER_MODE"
        fi
        if [ $? -ne 0 ]; then
            exit 25
        fi
        mv "$WALKER_WORK/result" "$OUTPUT"
        if [ $? -ne 0 ]; then
            exit 26
        fi
    fi
fi
